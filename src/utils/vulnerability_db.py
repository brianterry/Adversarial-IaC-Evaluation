"""
Vulnerability Database - Interface for Trivy security rules

This module provides access to 142 real-world vulnerability patterns from Trivy,
used by the Red Team agent to select and inject vulnerabilities into IaC code.

Data Source: Trivy Checks (https://github.com/aquasecurity/trivy-checks)
Original scraper: https://github.com/SymbioticSec/vulnerable-iac-dataset-generator
"""

import json
import logging
import random
from pathlib import Path
from typing import Any, Dict, List, Optional


class VulnerabilityDatabase:
    """Interface for vulnerability data retrieval using Trivy rules"""

    def __init__(self, db_path: Optional[str] = None):
        """
        Initialize the vulnerability database.
        
        Args:
            db_path: Path to the trivy_rules_db.json file. If None, uses default location.
        """
        self.db_path = db_path or self._get_default_db_path()
        self.logger = logging.getLogger(__name__)
        self.rules_db: Dict[str, Any] = {}
        self._load_database()

    def _get_default_db_path(self) -> str:
        """Get default path to Trivy rules database"""
        # Default location: src/data/trivy_rules_db.json
        default_path = Path(__file__).parent.parent / "data" / "trivy_rules_db.json"
        
        if default_path.exists():
            return str(default_path)
        
        # Fallback locations
        fallbacks = [
            Path("src/data/trivy_rules_db.json"),
            Path("data/trivy_rules_db.json"),
        ]
        
        for path in fallbacks:
            if path.exists():
                return str(path)
        
        self.logger.warning("Trivy rules database not found, using mock data")
        return ""

    def _load_database(self):
        """Load the Trivy rules database"""
        if not self.db_path or not Path(self.db_path).exists():
            self.logger.warning("Trivy database not found, using mock data")
            self.rules_db = self._get_mock_data()
            return

        try:
            with open(self.db_path, "r") as f:
                self.rules_db = json.load(f)

            self.logger.info(f"Loaded Trivy rules database from {self.db_path}")
            rule_sets = list(self.rules_db.get("rules", {}).keys())
            self.logger.info(f"Available rule sets: {rule_sets}")

        except Exception as e:
            self.logger.error(f"Failed to load Trivy database: {e}")
            self.rules_db = self._get_mock_data()

    def get_sample_for_prompt(
        self, cloud_provider: str, language: str
    ) -> Dict[str, Any]:
        """
        Get vulnerability samples for Red Team prompt context.
        
        Args:
            cloud_provider: Cloud provider (aws, azure, gcp/google)
            language: IaC language (terraform, cloudformation)
            
        Returns:
            Dictionary with sample vulnerabilities and metadata
        """
        # Normalize provider name
        provider_mapping = {
            "gcp": "google",
            "google": "google",
            "aws": "aws",
            "azure": "azure",
        }
        normalized_provider = provider_mapping.get(
            cloud_provider.lower(), cloud_provider.lower()
        )
        
        key = f"{language}_{normalized_provider}".lower()
        available_rules = self.rules_db.get("rules", {}).get(key, [])

        self.logger.info(f"Getting samples for: {key} ({len(available_rules)} rules available)")

        if not available_rules:
            self.logger.warning(f"No rules for {key}. Available: {list(self.rules_db.get('rules', {}).keys())}")
            return self._empty_response()

        # Sample up to 20 rules for prompt context
        sample_count = min(20, len(available_rules))
        sample_rules = random.sample(available_rules, sample_count)

        # Transform to vulnerability format
        sample_vulnerabilities = []
        for rule in sample_rules:
            vuln = self._transform_to_vulnerability(rule)
            if vuln:
                sample_vulnerabilities.append(vuln)

        # Get available services for logging
        services = list(set(rule.get("service", "unknown") for rule in available_rules))
        
        self.logger.info(f"Created {len(sample_vulnerabilities)} samples. Services: {services}")

        return {
            "sample_vulnerabilities": sample_vulnerabilities,
            "sample_vulnerability": sample_vulnerabilities[0] if sample_vulnerabilities else None,
            "available_count": len(available_rules),
            "database_type": "trivy-checks",
            "services_available": services,
            "sample_count": len(sample_vulnerabilities),
        }

    def _transform_to_vulnerability(self, rule: Dict) -> Optional[Dict]:
        """Transform a Trivy rule to vulnerability format for the Red Team"""
        try:
            # Extract severity from parsed metadata if available
            severity = "medium"
            parsed_metadata = rule.get("parsed_metadata")
            if parsed_metadata and isinstance(parsed_metadata, dict):
                severity = parsed_metadata.get("severity", "medium").lower()

            return {
                "rule_id": rule.get("rule_id", "unknown"),
                "title": rule.get("title", "Unknown vulnerability"),
                "description": f"Trivy security rule: {rule.get('title', 'Unknown')}",
                "severity": severity,
                "affected_component": "infrastructure",
                "injection_strategy": "trivy_yaml_injection",
                "business_impact": f"Security misconfiguration in {rule.get('service', 'infrastructure')}",
                "trivy_yaml_content": rule.get("yaml_content", ""),
                "file_name": rule.get("file_name", ""),
                "provider": rule.get("provider"),
                "service": rule.get("service"),
            }
        except Exception as e:
            self.logger.error(f"Failed to transform rule: {e}")
            return None

    def _empty_response(self) -> Dict[str, Any]:
        """Return empty response structure"""
        return {
            "sample_vulnerabilities": [],
            "sample_vulnerability": None,
            "available_count": 0,
            "database_type": "trivy-checks",
            "services_available": [],
            "sample_count": 0,
        }

    def get_database_stats(self) -> Dict[str, Any]:
        """Get statistics about the loaded database"""
        if not self.rules_db:
            return {"error": "Database not loaded"}

        rules = self.rules_db.get("rules", {})
        return {
            "total_rule_sets": len(rules),
            "rule_sets": list(rules.keys()),
            "total_rules": sum(len(rule_list) for rule_list in rules.values()),
            "rules_by_set": {key: len(rule_list) for key, rule_list in rules.items()},
            "database_source": self.rules_db.get("metadata", {}).get("source", "trivy-checks"),
        }

    def _get_mock_data(self) -> Dict[str, Any]:
        """Fallback mock data when database is unavailable"""
        return {
            "metadata": {"version": "1.0", "source": "mock-data", "total_rules": 3},
            "rules": {
                "terraform_aws": [
                    {
                        "rule_id": "MOCK-AWS-001",
                        "title": "S3 bucket with public access",
                        "provider": "aws",
                        "service": "storage",
                        "language": "terraform",
                        "yaml_content": "# Mock rule for S3 public access",
                        "trivy_rule": False,
                    }
                ],
                "terraform_azure": [
                    {
                        "rule_id": "MOCK-AZURE-001",
                        "title": "Storage account with public access",
                        "provider": "azure",
                        "service": "storage",
                        "language": "terraform",
                        "yaml_content": "# Mock rule for Storage account",
                        "trivy_rule": False,
                    }
                ],
                "terraform_google": [
                    {
                        "rule_id": "MOCK-GCP-001",
                        "title": "Storage bucket with public access",
                        "provider": "google",
                        "service": "storage",
                        "language": "terraform",
                        "yaml_content": "# Mock rule for GCS bucket",
                        "trivy_rule": False,
                    }
                ],
            },
        }
