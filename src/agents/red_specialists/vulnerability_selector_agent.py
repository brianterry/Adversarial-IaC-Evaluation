"""
Vulnerability Selector Agent

Second stage of Red Team Pipeline.
Selects vulnerabilities to inject based on the architecture design.
"""

import json
from typing import Any, Dict

from langchain_core.language_models.chat_models import BaseChatModel

from ...prompts import RedTeamPipelinePrompts
from .base import PipelineStage


class VulnerabilitySelectorAgent(PipelineStage):
    """
    Vulnerability selector that chooses which vulns to inject.
    
    Takes: Architecture design from Architect
    Produces: List of vulnerabilities with injection details
    """

    def __init__(
        self,
        llm: BaseChatModel,
        cloud_provider: str = "aws",
        language: str = "terraform",
        difficulty: str = "medium",
        vuln_count: int = 5,
    ):
        super().__init__(llm, cloud_provider, language)
        self.difficulty = difficulty
        self.vuln_count = vuln_count
        
        # Load vulnerability samples
        self.vulnerability_samples = self._load_vuln_samples()

    @property
    def stage_name(self) -> str:
        return "vulnerability_selector"

    @property
    def prompt_template(self) -> str:
        return RedTeamPipelinePrompts.VULNERABILITY_SELECTOR_AGENT

    def _load_vuln_samples(self) -> str:
        """Load vulnerability samples from database (compact format to save tokens)."""
        try:
            from pathlib import Path
            db_path = Path(__file__).parent.parent.parent.parent / "vendor/vulnerable-iac-generator/data/trivy_rules_db.json"
            if db_path.exists():
                with open(db_path) as f:
                    rules = json.load(f)
                # Handle both dict and list formats
                if isinstance(rules, dict):
                    # Extract rules from dict format (e.g., {"terraform_aws": [...], ...})
                    all_rules = []
                    for rule_set in rules.values():
                        if isinstance(rule_set, list):
                            all_rules.extend(rule_set)
                    rules = all_rules
                # Return COMPACT samples (just id, title, severity) to save tokens
                import random
                sample_rules = random.sample(rules, min(10, len(rules))) if rules else []
                compact_samples = [
                    {
                        "id": r.get("id", r.get("rule_id", "unknown")),
                        "title": r.get("title", r.get("description", ""))[:80],  # Truncate title
                        "severity": r.get("severity", "MEDIUM"),
                        "type": r.get("type", r.get("category", "unknown"))[:30],
                    }
                    for r in sample_rules
                ]
                return json.dumps(compact_samples, indent=2)
        except Exception as e:
            self.logger.warning(f"Could not load vuln samples: {e}")
        
        # Fallback samples
        return json.dumps([
            {"id": "AVD-AWS-0086", "title": "S3 bucket without encryption", "severity": "HIGH", "type": "encryption"},
            {"id": "AVD-AWS-0088", "title": "S3 bucket with public access", "severity": "CRITICAL", "type": "access_control"},
            {"id": "AVD-AWS-0057", "title": "IAM policy allows wildcard actions", "severity": "HIGH", "type": "iam"},
        ])

    def _format_prompt(self, input_data: Dict[str, Any]) -> str:
        """Format the selector prompt with architecture data."""
        return self.prompt_template.format(
            architecture_json=json.dumps(input_data, indent=2),
            difficulty=self.difficulty,
            vulnerability_samples=self.vulnerability_samples,
            vuln_count=self.vuln_count,
        )

    def _parse_response(self, response: str) -> Dict[str, Any]:
        """Parse selector response into vulnerability list."""
        json_content = self._extract_json(response)
        
        if not json_content:
            self.logger.warning("Could not extract JSON from selector response")
            return {"selected_vulnerabilities": []}
        
        try:
            data = json.loads(json_content)
            return {
                "selected_vulnerabilities": data.get("selected_vulnerabilities", []),
                "injection_narrative": data.get("injection_narrative", ""),
                "expected_detection_difficulty": data.get("expected_detection_difficulty", self.difficulty),
            }
        except json.JSONDecodeError as e:
            self.logger.warning(f"Failed to parse selector response: {e}")
            return {"selected_vulnerabilities": []}
